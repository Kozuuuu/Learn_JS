1. All about Variables
    a. Var
        var: Can be both redeclared and reassigned.
    b. let
        let: Cannot be redeclared in the same scope but can be reassigned.
    c. const
        const: Cannot be redeclared or reassigned.

    1.1 Variable Declaration
        a. var: Function-scoped, hoisted, can be redeclared and reassigned.
        b. let: Block-scoped, hoisted but not initialized, cannot be redeclared, can be reassigned.
        c. const: Block-scoped, hoisted but not initialized, cannot be redeclared or reassigned, must be initialized when declared.

    1.2 Hosting
        -JavaScript variables declared with var are "hoisted" to the top of their scope, meaning they can be accessed before their declaration, but they will be undefined until the actual line where they are initialized.
        -let and const are also hoisted, but they are not initialized and cannot be accessed until the code execution reaches their declaration line (known as the "temporal dead zone").

    1.3 Variable Naming Rules
        -Start with a letter: Variable names must begin with a letter (a-z or A-Z), an underscore _, or a dollar sign $.
        -No numbers at the beginning: You can't start a variable name with a number, but numbers can be used elsewhere.
        -Case-sensitive: JavaScript is case-sensitive, so myVariable and myvariable are different.
        -No spaces: Variable names cannot contain spaces.
        -No reserved keywords: You can't use JavaScript reserved keywords (like let, const, if, while) as variable names.
            ex. Valid: 'firstName', '_index', '$price', 'age2'
                Invalid: '2ndPlace', 'my variable', 'let'

    1.4 Variable Scope
        a. Global Scope: A variable declared outside of any function or block has global scope and can be accessed from anywhere in the code.
        b. Function Scope: Variables declared with var inside a function are only accessible within that function.
        c. Block Scope: Variables declared with let or const inside a block {} are only accessible within that block. 

====================================================================================================================================
====================================================================================================================================

2. Data Types
    a. Numbers: Represents both integer and floating-point numbers.
        ex. let age = 30;      // Integer
            let price = 9.99;  // Floating-point

    b. Strings: Represents a sequence of characters. Can be enclosed in single quotes ' ', double quotes " ", or backticks ` `.
        ex. let name = "John";

    c. Booleans: Represents a logical entity with two values: true or false.
        ex. let isTrue = true;

    d. Objects: Represents a collection of key-value pairs. Keys are strings (or Symbols), and values can be of any type.
        ex. let person = { 
                firstName: "Jane", 
                lastName: "Doe"
                age: 22
                isStudent: true
            };    

    e. Arrays: A special type of object used for ordered collections of items. Arrays can hold items of any type, including other arrays.
        ex. let colors = ["red", "green", "blue"];
            let mixed = ["apple", 42, true, [1, 2, 3]];

    f. Undefined: A variable declared but not assigned a value is undefined.
        ex. let x;
            console.log(x); // Outputs: undefined

    g. Null: Represents an intentional absence of any object value: 
        ex. let empty = null;

    h. Symbol: Represents a unique and immutable value, often used as object property keys.
        ex. let sym = Symbol('description');

    i. BigInt: Represents a whole number that can be arbitrarily large, with unlimited precision.
        ex. let bigNumber = 1234567890123456789012345678901234567890n;

    j. Function (a special type of object): Represents a block of code designed to perform a specific task. Functions can be assigned to variables, passed as arguments, and returned from other functions.
        ex. function greet(name) {
                return `Hello, ${name}!`;
            }
------------------------------------------------------------------------------------------------------------------------------------
    2.1 Type of Operator
        -The typeof operator in JavaScript returns the type of a variable or value.
        -typeof returns a string representing the type of a value.
        -Common types include number, string, boolean, object, function, undefined, symbol, and bigint.
            ex. let num1 = 42;
                console.log(typeof num1); // Outputs: "number"
            ex. function myFunction() {}
                console.log(typeof myFunction); // Outputs: "function"
            ex. let sym = Symbol();
                console.log(typeof sym); // Outputs: "symbol"
------------------------------------------------------------------------------------------------------------------------------------
    2.2 Object
        -an object is a complex data type that allows you to store collections of data in key-value pairs. 
        -Objects can hold values of any data type, including other objects.    

        a. Creating an Object
            a.1 Object Literals
                -Directly define an object with properties.
                    ex. let person = {
                            name: "Alice",
                            age: 30,
                            isStudent: false
                        };
            a.2 Using the new Object() Syntax
                -Create an object using the constructor
                    ex. let car = new Object();
                        car.make = "Toyota";
                        car.model = "Camry";
                        car.year = 2022;

        b. Accessing Object Properties
            b.1  Dot Notation
                -Access properties using a dot
                    ex. console.log(person.name); // Outputs: "Alice"
            b.2 Bracket Notation  
                -Access properties using brackets and a key.  
                    ex. console.log(person["age"]); // Outputs: 30

        c. Modifying Object Properties
            -Change the value of an existing property
            ex. person.age = 31; // Updates age
                person["isStudent"] = true; // Updates isStudent

        d. Adding new Properties
            -Add new key-value pairs to an object
                ex. person.email = "alice@example.com"; // Adds new property

        e. Deleting Properties
            -Remove a property from an object
                ex. delete person.email; // Removes the email property

        f. Methods in Objects
            -Functions stored as object properties
            ex. let dog = {
                    name: "Rex",
                    bark: function() {
                        console.log("Woof!");
                    }
                };
                dog.bark(); // Outputs: "Woof!"

        g. Nested Objects
            -Objects within objects
                ex. let company = {
                        name: "TechCorp",
                        address: {
                            city: "San Francisco",
                            state: "CA"
                        }
                    };
                    console.log(company.address.city); // Outputs: "San Francisco"
------------------------------------------------------------------------------------------------------------------------------------
    2.3 Object Prototypes 
        -Every JavaScript object has a prototype object from which it can inherit properties and methods. This prototype is itself an object, and it can have its own prototype, forming a prototype chain.
        -An objectâ€™s prototype from which it inherits properties
        -Creation: Object.create(proto).

        a.Prototype Basics
            -Every JavaScript object has a prototype, which is another object from which it inherits properties and methods.
            -Accessing Prototype: Use Object.getPrototypeOf(obj) to get the prototype of an object.

        b.Prototype chain
            -The prototype chain allows objects to inherit properties and methods from other objects.
                ex. let animal = {
                        eats: true
                    };
                    let dog = Object.create(animal);
                    console.log(dog.eats); // true, inherited from animal
        
        c. Object.prototype
            -The top-level prototype object from which all objects inherit. Contains methods like toString, hasOwnProperty, etc.
                ex. let obj = {};
                    console.log(obj.toString()); // "[object Object]"

        d. Custom Prototypes
            - Creating a Prototype: You can define your own prototype for objects
                ex. function Person(name) {
                        this.name = name;
                    }
                        Person.prototype.greet = function() {
                        return `Hello, ${this.name}`;
                    };
                    let alice = new Person('Alice');
                    console.log(alice.greet()); // "Hello, Alice"

        e. Prototype Inheritance
            - Objects can inherit properties and methods from other objects via prototypes.
                ex. let parent = {
                        value: 1
                    };
                    let child = Object.create(parent);
                    console.log(child.value); // 1, inherited from parent

        f. Modifying Prototypes
            - You can add or modify properties and methods on an object's prototype.
                ex. Array.prototype.first = function() {
                        return this[0];
                    };
                    let numbers = [1, 2, 3];
                    console.log(numbers.first()); // 1

        g. hasOwnProperty Method
            - Checks if an object has a specific property directly (not inherited).
                ex. let obj = { key: 'value' };
                    console.log(obj.hasOwnProperty('key')); // true
                    console.log(obj.hasOwnProperty('toString')); // false, inherited

------------------------------------------------------------------------------------------------------------------------------------
    2.4 Prototypal Inheritance
        - Prototypal inheritance allows objects to inherit properties and methods from other objects. This is achieved through the prototype chain. When accessing a property, JavaScript first checks the object itself, then its prototype, and so on up the chain.
        - Allows objects to inherit from other objects.
        - Access: JavaScript follows the prototype chain to find properties and methods.

            ex. let animal = {
                    eats: true
                };
                let dog = Object.create(animal);    
                dog.bark = function() {
                    console.log("Woof!");
                };
                console.log(dog.eats); // true, inherited from animal
                dog.bark(); // "Woof!", method defined on dog
----------------------------------------------------------------------------------------------------------------------------------
    2.5 Built in Objects
        a. Object
            - The base object from which all objects inherit. Provides methods for manipulating objects.
            ex. let obj = {};
                console.log(Object.keys(obj)); // []

        b. Array
            - Represents a list-like collection of elements.    
                ex. let arr = [1, 2, 3];
                    console.log(arr.length); // 3

        c. String
            - Represents a sequence of characters with methods for string manipulation.
                ex. let str = "Hello";
                    console.log(str.toUpperCase()); // "HELLO"

        d. Number
            - Represents numeric values, including integers and floating-point numbers.
                ex. let num = 123;
                    console.log(Number.isInteger(num)); // true

        e. Boolean
            - Represents a logical entity with two values: true or false.
                ex. let flag = true;
                    console.log(flag.toString()); // "true"

        f. Function
            - Represents a block of code designed to perform a task. Functions are also objects.
                ex. function greet() { return "Hello"; }
                    console.log(typeof greet); // "function"

        g. Date
            - Represents dates and times.
                ex. let now = new Date();
                    console.log(now.toDateString()); // Current date

        h. RegExp
            - Represents regular expressions for pattern matching in strings.
                ex. let regex = /abc/;
                    console.log(regex.test("abcdef")); // true
    
        i. Math
            - Provides mathematical constants and functions.
                ex. console.log(Math.PI); // 3.141592653589793
                    console.log(Math.sqrt(16)); // 4

        j. JSON
            - Provides methods for parsing and stringifying JSON data.
                ex. let obj = { name: "Alice" };
                    let jsonString = JSON.stringify(obj);
                    console.log(jsonString); // '{"name":"Alice"}'

        k. Error
            - Represents runtime errors.
                ex. try {
                        throw new Error("Something went wrong");
                    } catch (e) {
                        console.log(e.message); // "Something went wrong"
                    }

        l. Map
            - Represents a collection of key-value pairs where keys can be any data type.
                ex. let map = new Map();
                    map.set("key", "value");
                    console.log(map.get("key")); // "value"

        m. Set
            - Represents a collection of unique values.
                ex. let set = new Set();
                    console.log(set.has(2)); // true

===================================================================================================================================
===================================================================================================================================

3. Type Casting
    -Type casting in JavaScript involves converting a value from one data type to another
        
        a. Implicit Type Conversion (Coercion)
            -JavaScript automatically converts types in certain contexts.
                ex. String to Number:
                    let num = "5" * 2; // "5" is coerced to 5, result is 10
                ex. Number to String:   
                    let str = 10 + ""; // 10 is coerced to "10"
                ex. Boolean Context:
                    let bool = !!"Hello"; // Converts "Hello" to true

        b.  Explicit Type Conversion (Conversion)
                -Manually converting types using functions:
                    ex. To String: 
                            let num = 123;
                            let str = String(num); // "123"
                    ex. To Number:
                            let str = "123";
                            let num = Number(str); // 123
                    ex. To Boolean:
                            let value = 1;
                            let bool = Boolean(value); // true
                    ex. Using 'parseInt' and 'parseFloat'
                            let intStr = "123";
                            let intNum = parseInt(intStr); // 123

                            let floatStr = "123.45";
                            let floatNum = parseFloat(floatStr); // 123.45
 
==================================================================================================================================
==================================================================================================================================

4. Data Structures 
    a. Arrays
        -Description: Ordered collections of elements, which can be of any type.
        -Key Operations: Access, add, remove elements.
            ex. let fruits = ['apple', 'banana', 'cherry'];
                console.log(fruits[1]); // "banana"
                fruits.push('orange'); // Add to end  // ['apple', 'banana', 'cherry', 'orange']

    b. Objects
        -Description: Collections of key-value pairs, where keys are strings (or Symbols) and values can be of any type.
        -Key Operations: Access, add, modify, delete properties.
            ex. let person = {
                name: 'Alice',
                age: 30
                };
                console.log(person.name); // "Alice"
                console.log(person.age); // "30"
                person.age = 31; // Modify property

    c. Sets
        -Description: Collections of unique values. Unlike arrays, a Set does not allow duplicate values.
        -Key Operations: Add, delete, check for presence.
            ex. let numbers = new Set([1, 2, 3, 4]);
                numbers.add(5);
                console.log(numbers.has(3)); // true

    d. Maps
        -Description: Collections of key-value pairs where keys can be of any type (not just strings).
        -Key Operations: Set, get, delete, check for keys.
            ex. let map = new Map();
                map.set('name', 'Bob');
                console.log(map.get('name')); // "Bob"

    e. WeakSets
        -Description: Similar to Sets but with weak references to objects. Useful for memory management.
        -Key Operations: Add, delete, check for presence.
            ex. let weakSet = new WeakSet();
                let obj = {};
                weakSet.add(obj);
                console.log(weakSet.has(obj)); // true

    f. WeakMaps
        -Description: Similar to Maps but with weak references to keys. Useful for memory management.
        -Key Operations: Set, get, delete, check for keys.
            ex. let weakMap = new WeakMap();
                let obj = {};
                weakMap.set(obj, 'value');
                console.log(weakMap.get(obj)); // "value"
    
    g. Typed Arrays
        -Description: Arrays with a fixed type for elements (e.g., Int8Array, Uint16Array).
        -Key Operations: Same as regular arrays but with typed constraints.
            ex. let typedArray = new Uint8Array([1, 2, 3]);
                console.log(typedArray[1]); // 2
------------------------------------------------------------------------------------------------------------------------------------
    4.1 Structured Data
        -Structured Data refers to data that is organized in a predefined format or schema, making it easily searchable and manageable.

            a.JSON(JavaScript Object Notation)
                - A lightweight data interchange format that's easy to read and write for humans and easy to parse and generate for machines.
                - Key-value pairs, widely used in web APIs.
                    ex. {
                        "name": "Alice",
                        "age": 30,
                        "email": "alice@example.com",
                        "isActive": true
                        }

            b. XML(eXtensible Markup Language)
                - A markup language that defines rules for encoding documents in a format that is both human-readable and machine-readable.
                - Hierarchical structure with tags, used in various data interchange scenarios. b
                    ex. <person>
                            <name>Alice</name>
                            <age>30</age>
                            <email>alice@example.com</email>
                            <isActive>true</isActive>
                        </person>

            c.CSV(Comma-Separated Values)
                - A simple format for storing tabular data where each line represents a row and columns are separated by commas.
                - Tabular format, simple and used in spreadsheets and data export/import.
                    ex. name,age,email,isActive
                        Alice,30,alice@example.com,true
            
            d.Databases
                - structured collections of data organized in tables (relational databases) or documents (NoSQL databases).
                - Structured data stored in tables (relational) or documents (NoSQL).
                    ex. CREATE TABLE users (
                            id INT PRIMARY KEY,
                            name VARCHAR(100),
                            age INT,
                            email VARCHAR(100),
                            isActive BOOLEAN
                        );

            e. YAML(YAML Ain't Markup Language)
                - A human-readable data serialization standard that can be used to represent data structures.
                - Human-readable format, often used for configuration files.
                    ex. name: Alice
                        age: 30
                        email: alice@example.com
                        isActive: true

            f.HTML(HyperText Markup Language): 
                - The standard markup language used to create web pages.
                - Markup language for web pages, hierarchical tag-based structure.
                    ex. <html>
                            <body>
                                <h1>Alice</h1>
                                <p>Age: 30</p>
                                <p>Email: alice@example.com</p>
                                <p>Active: true</p>
                            </body>
                        </html>
------------------------------------------------------------------------------------------------------------------------------------
    4.2 JSON (JavaScript Object Notation) is a lightweight, text-based format used to represent structured data. It is commonly used for data interchange between a server and a client in web applications.

        a. JSON Structure
            Objects: Represented as key-value pairs enclosed in curly braces {}.
            Arrays: Ordered lists of values enclosed in square brackets [].
            Values: Can be strings, numbers, booleans, objects, arrays, or null.

        b. Basic Syntax
            b.1. Object:
                ex. {
                    "key": "value"
                    }
            b.2. Array:
                ex. [
                    "value1",
                    "value2"
                    ]
            EXAMPLE:
            {
                "name": "Alice",
                "age": 30,
                "isActive": true,
                "address": {
                "street": "123 Main St",
                "city": "Wonderland"
            },
            "phoneNumbers": ["123-456-7890", "987-654-3210"]
            }

        c. Data Types
            c.1. String
                - Enclosed in double quotes.
                    ex. "Hello, World!"
            c.2. Numbers 
                - Can be an integer or floating-point. 
                ex. "age": 25
            c.3. Boolean: true or false.
                ex. "isActive": true
            c.4.Object: 
                -Key-value pairs.
                    ex. "address": {
                            "street": "123 Main St",
                            "city": "Wonderland"
                        }
            c.5. Array:
                - Ordered list of values.
                    ex. "phoneNumbers": ["123-456-7890", "987-654-3210"]
            c.6. Null:
                - Represents a null value.
                    ex. "middleName": null
       
        d. Usage in JavaScript
            d.1. Parsing JSON: 
                -Convert JSON string to JavaScript object.
                    ex. let jsonString = '{"name": "Alice", "age": 30}';
                        let obj = JSON.parse(jsonString);
                        console.log(obj.name); // "Alice"
            d.2. Stringifying JSON:
                - Convert JavaScript object to JSON string.
                    ex. let obj = { name: "Alice", age: 30 };
                        let jsonString = JSON.stringify(obj);
                        console.log(jsonString); // '{"name":"Alice","age":30}'
        
        e. Key Points   
            -Human-Readable: JSON is text-based and easy to read and write.
            -Lightweight: Efficient for data interchange.
            -Interoperable: Used in many programming languages, including JavaScript.

        6. Common Uses
            -APIs: Data interchange between client and server.
            -Configuration Files: Storing settings in a structured format.
            -Data Storage: Saving structured data in files or databases.
-----------------------------------------------------------------------------------------------------------------------------------
    4.3 Indexed Collections 
        -in JavaScript are data structures where elements are accessed using numerical indexes. The main indexed collections in JavaScript are Arrays and Typed Arrays. Hereâ€™s a brief overview:

        a. Arrays
            - Ordered collection of elements accessed by numerical index (starting at 0).
                    ex. let fruits = ['apple', 'banana', 'cherry'];
                        console.log(fruits[1]); // "banana"
                        fruits.push('date'); // Adds "date" to the end

        b. Typed Arrays
            - Arrays for specific numeric types, used for handling binary data.
                    ex. let intArray = new Int16Array(5); // Array of 5 16-bit integers
                        intArray[0] = 100;
                        console.log(intArray[0]); // 100
    Summary:
        a. Array: General use, flexible types.
        b. Typed Array: Specific numeric types, used for binary data.

===================================================================================================================================
===================================================================================================================================

5. Equality Comparison 
    a. Value Comparison Operators
        a.1. == (Loose Equality)
            - Compares values after type conversion (coercion). Different types can be considered equal.
                ex. console.log(5 == '5'); // true (string '5' is converted to number 5)
                    console.log(true == 1); // true (true is converted to 1)

        a.2. === (Strict Equality)
            - Compares values without type conversion. Types must be the same to be considered equal. More Precise
                ex. console.log(5 === '5'); // false (no type conversion, different types)
                    console.log(true === 1); // false (boolean vs. number)
        
        a.3. Object.is
            - Object.is is a method in JavaScript that compares two values for strict equality, similar to ===, but with a few key differences in how it handles special cases like NaN and -0.
                ex. console.log(Object.is(25, 25)); // true
                    console.log(Object.is('hello', 'hello')); // true
                    console.log(Object.is({}, {})); // false (different objects in memory)
                        
            a.a. NaN
                - Object.is(NaN, NaN) returns true.
                - NaN === NaN returns false.
                    ex. console.log(Object.is(NaN, NaN)); // true
                        console.log(NaN === NaN); // false
            a.b. +0 and -0:
                - Object.is(+0, -0) returns false.
                - +0 === -0 returns true.
                    ex. console.log(Object.is(+0, -0)); // false
                        console.log(+0 === -0); // true

    b. Equality Algorithm
        b.1. Loosely Equal (==)
            - Compares two values for equality with type coercion.
            Algorithm:
                - If the types are the same, compare values directly.
                - If types differ, attempt type conversion and then compare.
            Example:
                console.log(5 == '5'); // true (type coercion)
                console.log(null == undefined); // true
    
        b.2. Strictly Equal (===)
            - Compares two values for equality without type coercion (type and value must be the same).
            Algorithm:
                - Check if the types are the same.
                - If so, compare values directly.
            Example:
                console.log(5 === 5); // true
                console.log(5 === '5'); // false (different types)

        b.3. SameValueZero
            - Used internally by methods like Object.is to compare values, including treating -0 and +0 as different and NaN as equal to NaN.
            Algorithm:
                - Treat -0 and +0 as different values.
                - Treat NaN as equal to NaN.
                - Compare values directly otherwise.
            Example:
                console.log(Object.is(-0, +0)); // false
                console.log(Object.is(NaN, NaN)); // true
        
        b.4. SameValue
            - Conceptually similar to SameValueZero, used for comparing values while handling special cases like NaN and -0 differently.
            Algorithm:
                - Treat -0 and +0 as the same.
                - Treat NaN as different from other values.
                - Compare values directly otherwise.
            Example:
                // SameValue is implemented by `===` but with subtle differences in special cases
                console.log(0 === -0); // true
                console.log(NaN === NaN); // false

    Summary:
        a.1. == Checks for equality with type conversion.
        a.2. === Checks for equality without type conversion, more precise.
        a.3. Object.is is used for comparing two values with special handling for NaN and -0.
             Itâ€™s more precise than === in specific edge cases.
        b.1. Loosely Equal (==): Compares values with type coercion.
        b.2. Strictly Equal (===): Compares values without type coercion.
        b.3. SameValueZero: Handles NaN and 0 comparisons.
        b.4. SameValue: Similar to SameValueZero, with special case handling.

===================================================================================================================================
===================================================================================================================================

6. Loop and Iterations
    
    a.for loop
        - Repeats a block of code a specific number of times.
            ex. for (let i = 0; i < 5; i++) {
                console.log(i);     // 0, 1, 2, 3, 4
                }

    b. while loop
        - Repeats a block of code while a condition is true.
            ex. let i = 0;
                while (i < 5) {
                    console.log(i);     // 0, 1, 2, 3, 4
                    i++;
                }

    c. do...while loop
        - Similar to while, but guarantees at least one execution.    
            ex. let i = 0;
                do {
                    console.log(i);     // 0, 1, 2, 3, 4
                    i++;
                } while (i < 5);

    d. for...of loop
        - Iterates over the values of an iterable (like an array).
            ex. let fruits = ['apple', 'banana', 'cherry'];
                for (let fruit of fruits) {
                    console.log(fruit); // "apple", "banana", "cherry"
                }

    e. for...in loop
        - Iterates over the enumerable properties of an object.
            ex. let obj = {a: 1, b: 2, c: 3};
                    for (let key in obj) {
                    console.log(key, obj[key]);      // "a 1", "b 2", "c 3"
                }

    f. Array.prototype.forEach()
        - Executes a function once for each array element. g
            ex. let numbers = [1, 2, 3];
                numbers.forEach(num => console.log(num)); // 1, 2, 3

    g. Array.prototype.map()
        - Creates a new array by applying a function to each element of an array.
            ex. let numbers = [1, 2, 3];
                let squared = numbers.map(num => num * 2);
                console.log(squared); // [2, 4, 6]

    h. Array.prototype.filter()
        - Creates a new array with elements that pass a condition. 
            ex. let numbers = [1, 2, 3, 4];
                let even = numbers.filter(num => num % 2 === 0);
                console.log(even); // [2, 4]

    i. Array.prototype.reduce()
        - Reduces an array to a single value by applying a function. 
            ex. let numbers = [1, 2, 3, 4];
                let sum = numbers.reduce((acc, num) => acc + num, 0);
                console.log(sum); // 10

    j. break
        - Exits the current loop immediately.
            ex. for (let i = 0; i < 5; i++) {
                if (i === 3) {
                    break; // Exits the loop when i is 3
                }
                console.log(i); // 0, 1, 2
                }

    k. continue:
        - Skips the current iteration and continues with the next one.
            ex. for (let i = 0; i < 5; i++) {
                if (i === 3) {
                    continue; // Skips the iteration when i is 3
                }
                console.log(i); // 0, 1, 2, 4
                }

    Summary:
        (a, b, c) Traditional Loops: for, while, do...while.
        (d, e, f) Modern Loops: for...of, for...in, forEach.
        (f, g, h, i) Array Methods: map, filter, reduce
        j. break: Stops the loop entirely.
        k. continue: Skips the rest of the current iteration and moves to the next one.

===================================================================================================================================
===================================================================================================================================

7. Control Flow
    -Control Flow in JavaScript determines the order in which statements, functions, and commands are executed. It includes various constructs to control the execution of code based on conditions and loops.
    
        a. Conditional Statements
            a.1. if Statement
                Executes code if a condition is true.
                    ex. let age = 18;
                        if (age >= 18) {
                        console.log("Adult");
                        }

            a.2. if...else Statement:
                - Executes one block if a condition is true, and another if it's false.
                    ex. let age = 16;
                        if (age >= 18) {
                            console.log("Adult");
                        } else {
                            console.log("Not an adult");
                        }
            
            a.3. if...else if...else Statement:
                - Checks multiple conditions.
                    ex. let score = 85;
                        if (score >= 90) {
                            console.log("A");
                        } else if (score >= 80) {
                            console.log("B");
                        } else {
                            console.log("C");
                        }

            a.4. switch Statement
                - Chooses among multiple options based on a variable's value.
                    ex. let day = 2;
                        switch (day) {
                        case 1:
                            console.log("Monday");
                            break;
                        case 2:
                            console.log("Tuesday");
                            break;
                        default:
                            console.log("Other day");
                        }
    
        b. Looping Constructs
            b.1. for Loop:
                - Repeats a block of code a specific number of times.
                    ex. for (let i = 0; i < 5; i++) {
                            console.log(i); // 0, 1, 2, 3, 4
                        }
                        
            b.2. while Loop:
                - Repeats a block of code while a condition is true.
                    ex. let i = 0;
                        while (i < 5) {
                            console.log(i); // 0, 1, 2, 3, 4
                            i++;
                        }

            b.3. do...while Loop:
                - Similar to while, but guarantees at least one execution.
                    ex. let i = 0;
                        do {
                            console.log(i); // 0, 1, 2, 3, 4
                            i++;
                        } while (i < 5);

        c. Control Flow Statements
            c.1. break:
                - Exits the current loop or switch statement immediately.
                    ex. for (let i = 0; i < 5; i++) {
                            if (i === 3) break; // Exits loop when i is 3
                            console.log(i); // 0, 1, 2
                        }

            c.2. continue:
                - Skips the current iteration and continues with the next one.
                    ex. for (let i = 0; i < 5; i++) {
                        if (i === 3) continue; // Skips printing 3
                        console.log(i); // 0, 1, 2, 4
                        }


        d. Exceptional Handling
            d.1. throw Statement:
                - Used to create custom errors.
                    ex. function checkNumber(num) {
                            if (num < 0) {
                                throw new Error("Negative number not allowed");
                            }
                        }
                        checkNumber(-1);    // Throws error

            d.2. try...catch...finally:
                - Handles errors that occur during execution.
                    ex. try {
                            // Code that may throw an error
                            let result = riskyOperation();
                        } catch (error) {
                            // Code to handle the error
                            console.log("An error occurred:", error.message);
                        } finally {
                            // Code that runs regardless of whether an error occurred or not
                            console.log("Execution complete");
                        }

            d.3. Error Objects:
                - Objects representing errors, with properties like message and name.
                    ex. try {
                            throw new Error("Something went wrong");
                        } catch (error) {
                            console.log(error.name); // "Error"
                            console.log(error.message); // "Something went wrong"
                        }
    Summary:
        a. Conditional Statements: Control flow based on conditions (if, else, switch).
        b. Loops: Repeat code (for, while, do...while).
        c. Control Flow Statements: Modify loop execution (break, continue).
        d. Exceptional Handling: Manage errors with throw, try...catch...finally, and use Error objects to represent errors.

===================================================================================================================================
===================================================================================================================================

8. expressions and Operators
    a. Conditional Operators
        a.1. Ternary Operator (? :):
            - Short-hand for if...else.
                ex. let age = 18;
                    let status = (age >= 18) ? "Adult" : "Minor";
                    console.log(status); // "Adult"
    
    b. Comma Operator
        - Executes multiple expressions in a single statement, returns the last expressionâ€™s value.
            ex. let x = (2, 3, 4);
                console.log(x); // 4

    c. Unary Operators
        - Operates on a single operand.
            Examples:
                ex.1. Increment (++):
                    let a = 5;
                    a++; // a is now 6
                ex.2. Decrement (--):
                    let b = 10;
                    b--; // b is now 9
                ex.3. Unary Negation (-):
                    let c = 5;
                    console.log(-c); // -5

    d. Relational Operators
        - Compare two values to determine their relationship.
            Examples:
                ex.1. Less Than (<):
                    console.log(3 < 5); // true
                ex.2. Greater Than (>):
                    console.log(7 > 2); // true

    e. Assignment Operators
        - Assign values to variables.
            Examples:
                ex.1. Simple Assignment (=):
                    let x = 10;
                ex.2. Addition Assignment (+=):
                    let y = 5;
                    y += 3; // y is now 8

    f. Comparison Operators
        - Compare values and return a boolean.
            Examples:
                ex.1. Equal to (==):
                    console.log(5 == '5'); // true (coercion)
                ex.2. Strict Equal (===):
                    console.log(5 === 5); // true

    g. Arithmetic Operators
        - Perform mathematical operations.
            Examples:
                ex.1. Addition (+):
                    console.log(5 + 3); // 8
                ex.2. Subtraction (-):
                    console.log(5 - 2); // 3
                ex.3. Multiplication (*):
                    console.log(4 * 3); // 12
                ex.4. Division (/):
                    console.log(8 / 2); // 4
    
    h. Bitwise Operators
        - Perform operations on binary representations of numbers.
            Examples:
                ex.1. AND (&):
                    console.log(5 & 3); // 1 (binary 0101 & 0011 = 0001)
                ex.2. OR (|):
                    console.log(5 | 3); // 7 (binary 0101 | 0011 = 0111)

    i. Logical Operators
        - Perform logical operations.
            Examples:
                ex.1. AND (&&):
                    console.log(true && false); // false
                ex.2. OR (||):
                    console.log(true || false); // true
                ex.3. NOT (!):
                    console.log(!true); // false

    j. BigInt Operators
        - Handle large integers.
            Example:
                let big1 = 1234567890123456789012345678901234567890n;
                let big2 = 9876543210987654321098765432109876543210n;
                console.log(big1 + big2); // BigInt sum

    k. String Operators
        - Perform operations on strings.
            Examples:
                Concatenation (+):
                    let greeting = "Hello, " + "world!";
                    console.log(greeting); // "Hello, world!"
    
    Summary:
        Conditional Operators: ? :
        Comma Operator: ,
        Unary Operators: ++, --, -
        Relational Operators: <, >
        Assignment Operators: =, +=, etc.
        Comparison Operators: ==, ===
        Arithmetic Operators: +, -, *, /
        Bitwise Operators: &, |
        Logical Operators: &&, ||, !
        BigInt Operators: Handle large integers with n
        String Operators: + for concatenation

===================================================================================================================================
===================================================================================================================================

9. FUNCTIONS IN JAVASCRIPT
    9.1 Functions Parameters
        a. Default Parameters
            - Allow functions to have default values for parameters if none are provided.
                Example:
                    function greet(name = 'Guest') {
                        return `Hello, ${name}`;
                    }
                    console.log(greet()); // "Hello, Guest"
                    console.log(greet('Alice')); // "Hello, Alice"
        b. Rest Parameters
            - Collect multiple arguments into an array.
                Example:
                    function sum(...numbers) {
                        return numbers.reduce((acc, curr) => acc + curr, 0);
                    }
                    console.log(sum(1, 2, 3, 4)); // 10

    9.2. Arrow Functions
        - Shorter syntax for functions that do not have their own this context.
            Example:
                const add = (a, b) => a + b;
                console.log(add(2, 3)); // 5

    9.3. Immediately Invoked Function Expressions (IIFE)
        - Functions that execute immediately after being defined.
            Example:
                (function() {
                    console.log("IIFE executed");
                })();

    9.4. Arguments Object
        - An array-like object containing all arguments passed to a function.
            Example:
                function showArgs() {
                    console.log(arguments);
                }
                showArgs(1, 2, 3); // { 0: 1, 1: 2, 2: 3, length: 3 }

    9.5. Scope and Function Stack
        a. Recursion
            - A function calling itself to solve a problem in smaller chunks.
                Example:
                    function factorial(n) {
                        if (n <= 1) return 1;
                        return n * factorial(n - 1);
                    }
                    console.log(factorial(5)); // 120

        b. Lexical Scoping
            - Functions have access to variables defined in their outer scope.
                Example:
                    function outer() {
                        let outerVar = 'I am outside';
                        function inner() {
                            console.log(outerVar); // Accesses outerVar
                        }
                        inner();
                    }
                    outer(); // "I am outside"

        c. Closures
            - Functions that retain access to variables from their lexical scope even after the outer function has finished executing.
                Example:
                    function createCounter() {
                        let count = 0;
                        return function() {
                            count++;
                            return count;
                        };  
                    }
                    const counter = createCounter();
                    console.log(counter()); // 1
                    console.log(counter()); // 2

    9.6. Built-in Functions
        - Functions provided by JavaScript that are available globally.
            Examples:
                ex.1 parseInt:
                    console.log(parseInt('10', 10)); // 10
                ex.2 parseFloat:
                    console.log(parseFloat('10.5')); // 10.5
                ex.3 isNaN:
                    console.log(isNaN('hello')); // true

    Summary:
        9.1. Function Parameters: Default and rest parameters for handling arguments.
        9.2. Arrow Functions: Concise syntax for functions.
        9.3. IIFE: Functions that execute immediately.
        9.4. Arguments Object: Provides access to all arguments passed to a function.
        9.5. Scope and Function Stack: Includes recursion, lexical scoping, and closures.
        9.6. Built-in Functions: Predefined functions provided by JavaScript.

===================================================================================================================================
===================================================================================================================================

10. DOM APIs (Document Object Model APIs)
    -The DOM API provides a way to interact with and manipulate HTML and XML documents. It represents the document structure as a tree of objects.

        a. Document Object
            - Represents the entire document.
                Examples:
                    ex.1 Accessing Elements:
                        let header = document.getElementById('header');
                    ex.2 Creating Elements:
                        let newDiv = document.createElement('div');
                        document.body.appendChild(newDiv);
                        
        b. Element Object
            - Represents individual elements in the DOM.
                Examples:
                    ex.1. Modifying Attributes:
                        let link = document.querySelector('a');
                        link.setAttribute('href', 'https://example.com');
                    ex.2. Changing Content:
                        let paragraph = document.querySelector('p');
                        paragraph.textContent = 'New text content';

        c. Node Object
            - Represents a node in the DOM tree (can be an element, text, or comment).
                Ex.1. Traversing Nodes:
                        let firstChild = document.body.firstChild;
                        let parentNode = document.body.parentNode;

        d. Event Handling
            - Allows interaction with user actions.
                Examples:
                    ex.1. Adding Event Listeners:
                        let button = document.querySelector('button');
                        button.addEventListener('click', () => {
                            alert('Button clicked!');
                        });
                    ex.2. Removing Event Listeners:
                        function handleClick() {
                            console.log('Button clicked');
                        }
                        button.addEventListener('click', handleClick);
                        button.removeEventListener('click', handleClick);

        e. Traversing and Manipulating the DOM
            - Navigate and modify the DOM tree.
                Examples:
                    ex.1. Selecting Elements:
                        let divs = document.querySelectorAll('div');
                    ex.2. Changing Styles:
                        let box = document.getElementById('box');
                        box.style.backgroundColor = 'blue';
                    ex.3. Inserting Elements:
                        let newElement = document.createElement('p');
                        newElement.textContent = 'Inserted Paragraph';
                        document.body.appendChild(newElement);

        f. Document Methods
            Description: Various methods for interacting with the document.
                Examples:
                    ex.1. getElementById:
                        let header = document.getElementById('header');
                    ex.2. querySelector:
                        let firstDiv = document.querySelector('div');
                    ex.3. createElement:
                        let newElement = document.createElement('span');
    Summary:
        1. Document Object: Interact with the whole document.
        2. Element Object: Manipulate specific elements.
        3. Node Object: Work with different types of nodes in the DOM.
        4. Event Handling: Add and remove event listeners.
        5. Traversing and Manipulating the DOM: Navigate and modify the document structure.
        6. Document Methods: Basic methods for selecting and creating elements.

===================================================================================================================================
===================================================================================================================================

11. Strict Mode in JavaScript
    -Strict Mode is a way to opt into a restricted version of JavaScript. It helps catch common coding mistakes and unsafe actions, making your code more predictable and easier to debug.

        11.1. Enabling Strict Mode
            - You can enable strict mode for an entire script or for individual functions.
                a. Whole Script:
                    'use strict';
                    // Entire script runs in strict mode
                    let x = 3.14;
                b. Function Scope:
                    function myFunction() {
                        'use strict';
                        // Code inside this function runs in strict mode
                        let y = 2.71;
                    }
                    
        11.2. Changes and Restrictions in Strict Mode
            a. Eliminates this Coercion:
                - In strict mode, this is undefined in functions that are called without a context.
                    Example:
                        function checkThis() {
                            console.log(this); // undefined in strict mode
                        }
                        checkThis();
                
            b. Disallows Duplicate Parameter Names:
                - You can't have duplicate parameters in function definitions.
                    Example:
                        function sum(a, a) { // SyntaxError in strict mode
                            return a + a;
                        }

            c. Forbids with Statement:
                - The with statement is not allowed.
                    Example:
                        with (Math) { // SyntaxError in strict mode
                            console.log(PI);
                        }

            d. Makes eval Safer:
                - Code executed inside eval does not affect the outer scope.
                    Example:
                        eval('var x = 5;');
                        console.log(x); // ReferenceError: x is not defined
            
            f. Prevents Assignments to Non-Writable Properties:
                - You cannot assign values to read-only properties.
                    Example:
                        Object.defineProperty(window, 'PI', {
                            value: 3.14,
                            writable: false
                        });
                        PI = 3.14159; // TypeError in strict mode
                
            g. Disallows Deleting Variables:
                - You cannot delete variables or function names.
                    Example:
                        let x = 10;
                        delete x; // SyntaxError in strict mode

        11. 3. Benefits of Using Strict Mode
                Error Prevention: Helps catch common errors early in development.
                Improved Performance: Some JavaScript engines optimize code better in strict mode.
                Safer Code: Reduces the likelihood of code having bugs or behaving unexpectedly.

        Summary
            Strict Mode: A way to enforce a stricter parsing and error handling in JavaScript.
            Enabling: Use 'use strict'; at the beginning of a script or function.
            Restrictions: Includes eliminating this coercion, disallowing duplicate parameters, forbidding with, making eval safer, preventing assignments to non-writable properties, and disallowing deleting variables.

===================================================================================================================================
===================================================================================================================================

12. Using the this Keyword in JavaScript
    12.1. In a Method
        - Inside a method of an object, this refers to the object itself.
            Example:
                const person = {
                    name: 'Alice',
                    greet: function() {
                        return `Hello, ${this.name}`;
                    }
                };
                console.log(person.greet()); // "Hello, Alice"

    12.2. In a Function
        - In a regular function (not a method), this refers to the global object (window in browsers) or undefined in strict mode.
            Example:
                function showThis() {
                    console.log(this); // Window (or undefined in strict mode)
                }
                showThis();

    12.3. Using It Alone
        - When this is used alone (not within an object or function), its behavior depends on the context. Generally, it refers to the global object or undefined.
            Example:
                console.log(this); // Window (or undefined in strict mode)

    13.4. In Event Handlers
        - In event handlers, this refers to the element that triggered the event.
            Example:
                document.getElementById('myButton').addEventListener('click', function() {
                    console.log(this); // Button element
                });
    
    13.5. In Arrow Functions
        - Arrow functions do not have their own this context. Instead, this is lexically inherited from the surrounding function or global scope.
            Example:
                const obj = {
                    name: 'Bob',
                    greet: function() {
                        setTimeout(() => {
                            console.log(this.name); // Bob (inherited from obj)
                        }, 1000);
                    }
                };
                obj.greet();

    13.6. Function Borrowing
        - Allows a function to be used by a different object.
            Example:
                const person1 = {
                    name: 'John',
                    greet: function() {
                        return `Hello, ${this.name}`;
                    }
                };
                const person2 = {
                    name: 'Jane'
                };
                console.log(person1.greet.call(person2)); // "Hello, Jane"

13.7 Explicit Binding
    a. apply
        - Calls a function with a given this value and arguments provided as an array.
            Example:
                function greet(greeting) {
                    return `${greeting}, ${this.name}`;
                }
                const person = { name: 'Alice' };
                console.log(greet.apply(person, ['Hello'])); // "Hello, Alice"

    b. call
        - Calls a function with a given this value and arguments provided individually.
            Example:
                function greet(greeting, punctuation) {
                    return `${greeting}, ${this.name}${punctuation}`;
                }
                const person = { name: 'Bob' };
                console.log(greet.call(person, 'Hi', '!')); // "Hi, Bob!"

    c. bind
        Description: Returns a new function with a given this value and arguments. The new function can be called later.
            Example:
                function greet(greeting) {
                    return `${greeting}, ${this.name}`;
                }
                const person = { name: 'Charlie' };
                const greetCharlie = greet.bind(person);
                console.log(greetCharlie('Hello')); // "Hello, Charlie"

    Summary
        a. this Keyword: Refers to the context in which a function is called. Behavior varies based on usage (method, function, event handler, arrow function).
        b. Function Borrowing: Using a function from one object with another objectâ€™s context.
        c. Explicit Binding: Methods like apply, call, and bind are used to explicitly set the this value for a function.

===================================================================================================================================
===================================================================================================================================




===================================================================================================================================
===================================================================================================================================



===================================================================================================================================
===================================================================================================================================



===================================================================================================================================
===================================================================================================================================



